//алгоритм должен быть ЭКСТРЕМАЛЬНО быстрый
//поэтому, он будет использовать вперемешку SSE и SSE2 и максимальную оптимизацию
//надеюсь, что получится алгоритм сделать суперскалярным (к сожалению, почти не получилось)
//в том числе ассемблерные циклы, и movntps
//стек будет использоваться всего лишь h раз
//не CUDA конечено, но... прирост скорости в 6 раз! эгегееее!!

//сохраняем регистры, ибо мы их сейчас будем портить
push edi
push esi
push ebx
push ebp

//инецылезируем константы
mov eax, w
imul eax, h
shl eax, 2
//указатель карты должен показывать на последнее число
//ибо для того чтобы выходным резудбтатом можно было пользоваться, мы его будем на каждой итерации уменьшать
//поскоку основная проблема сдешних циклов, это декремент ecx с проверкой на ноль, что не совсем соотвествует
//нормальному человечьему мышлению, когда счетчкики, как у нормальных людей, увеличивваются, а не наоборот..
//и получается, что прорисовку алгоритм делает С НИЗУ, и а не сверху
//ну блять, ну вот все через жопу, все не как у людей! :))
mov edi, map
add edi, eax
sub edi, 16

//запоминаем переменные
mov ebx, nmax
mov eax, w

push sender
//во все-х случаях, в младших разрядах будет храниться x, а в старших y
//надо этого всегода придерживаться и учитывать, ибо movaps [структура], регистр вернет именно такой порядок...

//вычисляем коэффициенты масштабирования, а также начальные значения
//для всего этого изобилия, у нас будут использоваться регистры xmm6 (коэффициенты) и xmm7 (смещения)
movlpd xmm6, ystart
shufpd xmm6, xmm6, 1
movlpd xmm6, xstart


//грузим коэффициенты размерности...
cvtsi2sd xmm7, hu
shufpd xmm7, xmm7, 1
cvtsi2sd xmm7, wu

//надо всю эту хрень умножить(вернее поделить) на масштаб
//грузим масштааааб
movlpd xmm0, zscale
shufpd xmm0, xmm0, 0

//ии деелииимм! (вернее множим)
mulpd xmm7, xmm0
//и вот теперь мы имеем нужные коэффициенты)

//еще один момент: в xmm5 пихаем константу, отвечающую за максимальный модуль
//xorpd xmm5, xmm5
//movlpd xmm5, ss1
//shufpd xmm5, xmm5, 1
movlpd xmm5, cconst

//наконец, xmm4 будет содержать промежуточное значение итераций, 4 штуки
//сдвиг будем выполнять с помощью shufps
//и не вздумайте ляпнуть мне тут, что жто невозможно!!
xorpd xmm4, xmm4
//просто кэп вам наменул, есть какието более человечные команды логического сдвига, из MMX..
//товарищь Кэп, мы как нибуть без вас разберемся, ок?!1

mov ecx, h

//первый цикл по строчкам
@for_height:

  //запоминаем счетчик
  mov esi, ecx
  mov ecx, eax

  //и закручиваем второй цикл, уже по пикселям
  @for_width:
	//тестирование комплексного числа должно производиться только в памяти, и нигде более
	mov ebp, ecx  //сохраняем счетчик цикла
	mov ecx, ebx  //устанавливаем nmax

	//далее нужно вычислить координаты точки
	//вычисляем... по аналогии с тем что выше
	//только мы помним, что нужные значения находятся в регистрах!
	cvtsi2sd xmm0, esi
	shufpd xmm0, xmm0, 1
	cvtsi2sd xmm0, ebp

	//множим на необходимые коэффициенты
	divpd xmm0, xmm7

	//прибавляем стартовое положение
	addpd xmm0, xmm6

	//вроде все готово. xmm0 содержит константу c. xmm6 и xmm7 заняты, помним!
	//здесь у нас будет работать небольшая псевдосуперскалярная матрица
	//и первым его элементом будет xmm1
	//в котором, кстати, изначально ноль
	xorpd xmm1, xmm1


	@trace_step:

	  //возводим эту хрень в квадрат

	  // ; re := dest.re * dest.re - dest.im * dest.im;
	  // ; im := dest.re * dest.im + dest.im * dest.re;

	  movapd xmm3, xmm1

	  //у второго регистра меняем все местами
	  //movapd xmm2, xmm1
	  shufpd xmm3, xmm3, 1

	  //перемножаем (действие первое)
	  mulpd xmm3, xmm1  //; re*im + im*re
	  mulpd xmm1, xmm1  //; re*re - im*im

	  //xmm1 : re*re - im*im
	  //xmm3 : re*im + im*re


	  //теперь, нужно у первого регистра старшую часть отнять у младшей
	  //а у второго обе части сложить
	  //и сделать так, чтобы результаты стали частями третьего регистра
	  //и тогдааа!!! мы получим то что хочим, тоесть наше комплексное прозиведение

	  movapd xmm2, xmm1

	  unpcklpd xmm1, xmm3
	  unpckhpd xmm2, xmm3

	  //в SSE3, оказывается! еще есть команда ADDSUBPD
	  //и очень похоже, что она - именно то что нам нада
	  //ADDSUBPD XMM1, XMM2
	  db $66, $0f, $d0, $ca
	  //ИЧСХ, Работает, Сука!


	  //хорошая попытка сделать быстрее. к сожалению, неудачная
	  (****************************************
	  //И... Снова SSE3! :)
	  //грузим числа в хитром виде
	  //movddup xmm3, xmm1
	  db $f2, $0f, $12, $d9
	  shufpd xmm1, xmm1, 1

	  //movddup xmm2, xmm1
	  db $f2, $0f, $12, $d1

	  //множим
	  mulpd xmm3, xmm1
	  mulpd xmm2, xmm1

	  //меняем числа местами в первой части
	  shufpd xmm3, xmm3, 1
	  ***************************************)


	  //УсТаРеЛо
	  (********************************************************************
	  //теперь в xmm1 младншие части бывших xmm1 и xmm3, а в xmm3 - старшие
	  //остается только их както хитро сложитьвычесть

	  xorpd xmm3, xmm3
	  unpckhpd xmm3, xmm2

	  //стираем младшую часть и прибавляем
	  //а после этого сохраненную младшую часть вычииитаем!

	  addpd xmm1, xmm3
	  subsd xmm1, xmm2
	  //*********************************************************************)

	  //////////////////////////
	  {pushad
	  movaps [edi], xmm1
	  mov eax, edi
	  call memview
	  popad  }
	  //////////////////////////

	  //ну все! теперь в xmm1, кажись, валяетсо комплексный квадрат
	  //а поскоку он там лежит, к нему надо приебtybnm xmm0!
	  addpd xmm1, xmm0


	  movapd xmm3, xmm1

	  //и еще одна есть инструкция, интересная, но уже в SSE4
	  //и умеет она делать скалярное произведение, и зовется она DPPD...

	  //DPPD XMM3, XMM1, $49 //1 | 16 | 32
	  //db $66, $0f, $3a, $41, $d9, 49
	  //РАБООТААЕЕЕТТТ!!!! мой CPU поддерживает SSE4! АААА!!!
	  //а также, новостью является то, что компейлятор, встроеный в Dev-C++, тоже поддерживает SSE4. чтож, похвально.
	  //чего вот не скажешь о нешей дельфи 7..


	  //дальше надо найти модуль по оптимизированной технологии
	  //оптимизированная технология была безнадежно устарела, и заменена на sse4.dppd
	  //********************************************************************
	  movapd xmm2, xmm1
	  mulpd xmm2, xmm2
	  //перемножили, теперь части надо сложить
	  movapd xmm3, xmm2
	  shufpd xmm3, xmm2, 1
	  //переставили, складываем
	  addsd xmm3, xmm2
	  //*********************************************************************//

	  //младшая часть xmm3 теперь содержит квадратный модуль
	  ucomisd xmm3, xmm5
	  //сравниваем, и нас интересует только значение флага CF

	  //если меньше, то мы кажется живы
	  jnc @are_dead

	//как выяснилось, такой цикл работает.. быстрее?!
	dec ecx
	//test ecx, ecx
	jnz @trace_step

	//loop @trace_step

	@are_dead:

	//тут у нас яяяявноо чему то равен ecx, и чем, нам надо во первых выяснить, во вторых преобразовать в нормальное, человеческое представление
	mov edx, ebx
	sub edx, ecx
	//ураа!! edx содержит искомео количество итераций! ураа!!
	//признаться, я слегка запарился его искать

	//поскольку известно, мы складываем его в xmm4
	//а сначала его двигаем, блять! блять, блять, и блять еше раз!
	//вроде так...
	shufps xmm4, xmm4, 147 //10,01,00,11
	cvtsi2ss xmm4, edx
	//правда еще есть команды логических сдвигов из MMX..

	//лулз получается в том, что в выходном массиве у нас получаются ФЛОАТЫ, БЛЯТЬ
	//ладно хуй с вами, флоаты так флоаты... учитывая что у нас будет еще линейная интерполяция, это наверно даже к лучшему
	//просто пока это писалось, никто даже и не догадывался о существаоании интересной такой команды CVTTPS2DQ...

	//смысл дальнейшего кода в сбросе регистра xmm4 по требованию, т.е по достижению его заполненности
	//далее олгаритм довольно прост. во первых, интересуемся, чему равен j:
	//регистр ecx тут уже не нужен, он переписывается несколькими командами ниже
	mov ecx, ebp
	dec ecx
	and ecx, 3 //если кратно 4м
	jnz @skip_flush

	  //сбрасываем этот ебучий регистр
	  movntps [edi], xmm4

	  //двигаем адрес на карте (отнимаем)
	  sub edi, 16

	@skip_flush:
	//весь смысл хрень выше, как вы могли уже догадаться, это сброс 16 байтов в память каждые 4 пикселя
	//на самом деле, работает как часы


	//вспоминаем значение счетчика
	mov ecx, ebp

  //цикл по элементам строки
  dec ecx
  //test ecx, ecx
  jnz @for_width
  //loop @for_width

//цикл по строкам, вспоминаем его щщоттчик
mov ecx, esi

//тут запилим небольшой прогресс, срабатывающий раз в дохрена строк
mov edx, ecx
and edx, $1F

//небольшой костыльчик для прогрессбара
jnz @no_progress
	 
  pushad

  sub esp, 128

  movups [esp], xmm0
  movups [esp + $10], xmm1
  movups [esp + $20], xmm2
  movups [esp + $30], xmm3

  movups [esp + $40], xmm4
  movups [esp + $50], xmm5
  movups [esp + $60], xmm6
  movups [esp + $70], xmm7

  add esp, 160

        pop edx

  sub esp, 164
	push ecx
        push edx
	call TMandelbrotMap.cb_progress

  movups xmm0, [esp]
  movups xmm1, [esp + $10]
  movups xmm2, [esp + $20]
  movups xmm3, [esp + $30]

  movups xmm4, [esp + $40]
  movups xmm5, [esp + $50]
  movups xmm6, [esp + $60]
  movups xmm7, [esp + $70]

  add esp, 128

  test eax, eax
  popad
  jnz @lets_fuck

@no_progress:

dec ecx
//кэп вам снова говорит, что test делать не надо, ибо dec УЖЕ выставляет все нужные флаги..
//test ecx, ecx
jnz @for_height

//вспоминаем старое значение регистров
@lets_fuck:
pop ebx
pop ebp
pop ebx
pop esi
pop edi